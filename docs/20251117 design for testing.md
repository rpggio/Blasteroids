## Architectural Guidance for Phaser with Headless Testing

**Treat Phaser scenes as thin presentation layers, not business logic containers.** The most critical architectural decision is resisting Phaser's gravitational pull toward embedding logic directly in game objects and scenes. Instead, maintain a separate game state layer that knows nothing about Phaser—pure TypeScript/JavaScript classes handling entity management, physics calculations, collision responses, and game rules. Your Phaser scenes should merely *read* from this state and *update* sprite positions, not contain the authoritative game logic. This separation proves expensive to retrofit but trivial to maintain from day one.

Concretely, avoid patterns like `this.player.body.velocity.x = 200` scattered throughout scene update loops. Instead, maintain a `GameWorld` class tracking entity positions, velocities, and states independently. The Phaser scene's update method becomes: `this.playerSprite.x = this.gameWorld.player.position.x`. This indirection feels wasteful initially but enables running game logic at any speed, on any platform, with zero rendering dependencies. Your headless tests manipulate the `GameWorld` directly while Phaser scenes remain dumb display adapters.

**Use `@geckos.io/phaser-on-nodejs` for headless execution, but understand its constraints.** This package provides the most mature Phaser server-side solution, mocking Canvas APIs and enabling physics engines to run headless. Setup requires installing canvas (`npm install canvas`) and creating a headless configuration that disables rendering but preserves game logic. Critical limitation: Phaser's asset loading system expects browser APIs, so texture/audio loading requires special handling—either mock the assets entirely for tests or use data URIs for minimal required resources. The physics engines (Arcade, Matter) work reliably headless, but anything touching WebGL or advanced rendering features will break.

Your test structure should initialize Phaser with `type: Phaser.HEADLESS`, create scenes programmatically, advance time manually with `scene.scene.systems.game.loop.tick()`, and verify state changes in your logic layer, not Phaser objects. Example: after advancing 60 frames with thrust applied, assert `gameWorld.player.velocity.y < 0`, not sprite positions. Testing collision detection requires spawning entities at specific coordinates, advancing physics, and checking your collision event callbacks fired with correct entities—the Phaser physics system runs normally, but you're validating your game logic's response, not Phaser's internal correctness.

**Accept that certain behaviors require browser testing, no matter your architecture.** Input handling edge cases, rendering performance with particle effects at scale, audio synchronization timing, and cross-browser compatibility issues fundamentally cannot be tested headlessly. Allocate ~10% of your test suite to Playwright/Puppeteer browser tests covering these scenarios while keeping 90% as fast, headless unit and integration tests. The browser tests should focus on critical user paths—main menu navigation, game start to first enemy encounter, multiplayer connection establishment—rather than comprehensive coverage of every mechanic.

**The multiplayer testing scenario requires dual-mode thinking.** For authoritative server architecture, run your headless `GameWorld` on the server with Phaser only on clients, dramatically simplifying testing since server logic never touches rendering. For client-predicted networking, both client and server run game logic, requiring deterministic physics and synchronized state—this proves significantly harder to test but enables better latency handling. Choose authoritative server architecture unless you have compelling performance requirements and team expertise with deterministic networking. The testing complexity difference is substantial: authoritative servers test game logic once headlessly, while client-predicted systems require validating synchronization between client and server instances under variable network conditions.

**AI agents can assist with test generation once this architecture exists, but cannot create it.** With separated logic and comprehensive headless tests, agents can generate test cases for new mechanics by following existing patterns—"write tests for a dash ability similar to the thrust tests." Without that foundation, agents cannot determine what to test or how to validate results, producing either trivial tests checking Phaser internals or brittle tests depending on rendering state. The architecture enables automation; automation doesn't create architecture.
